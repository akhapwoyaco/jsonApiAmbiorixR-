#   if (length(request_history[[key]]) >= config$rate_limit) {
#     res$status <- 429
#     res$send(list(error = "Rate limit exceeded"))
#     return(FALSE)
#   }
#
#   # Add current request
#   request_history[[key]] <- c(request_history[[key]], timestamp)
#
#   return(TRUE)
# }
rate_limit_middleware <- function(req, res) {
tryCatch({
# Debug log
logger::log_debug(paste("Rate limit middleware called with:", class(req), class(res)))
# Simple rolling window rate limiting
timestamp <- as.numeric(Sys.time())
key <- req$remote_addr
# Ensure request_history exists in global environment
if (!exists("request_history", envir = .GlobalEnv)) {
request_history <<- new.env()
logger::log_debug("Created new request_history environment")
}
# Get or initialize client history
client_history <- if (exists(key, envir = request_history)) {
request_history[[key]]
} else {
logger::log_debug(paste("Initializing history for client:", key))
numeric(0)
}
# Clean old requests (more than 60 seconds old)
client_history <- client_history[client_history > (timestamp - 60)]
# Check rate limit
if (length(client_history) >= config$rate_limit) {
logger::log_warn(paste("Rate limit exceeded for client:", key))
res$status <- 429
res$send(list(
error = "Rate limit exceeded",
message = "Too many requests, please try again later"
))
return(FALSE)
}
# Add current request and update history
client_history <- c(client_history, timestamp)
request_history[[key]] <- client_history
# Add headers to show rate limit status
remaining <- config$rate_limit - length(client_history)
res$header("X-RateLimit-Limit", as.character(config$rate_limit))
res$header("X-RateLimit-Remaining", as.character(remaining))
return(TRUE)
}, error = function(e){
logger::log_error(paste("Rate limit middleware erro: ", e$message))
res$status = 500
res$send(list(error = "Server error in rate limiting"))
return(FALSE)
}
)
}
#' Authentication middleware
#'
#' @param req Request object
#' @param res Response object
#' @return Boolean indicating if request should proceed
auth_middleware <- function(req, res) {
tryCatch({
# debug logger
logger::log_debug(paste("Auth middleware called with: ", class(req), " ",  class(res)))
#
auth_header <- req$headers$Authorization
# Check if header exists
if (is.null(auth_header)) {
logger::log_warn("Missing Authorization header")
res$status <- 401
res$json(list(error = "Authentication required"))
return(FALSE)
}
# trim any ws
auth_header <- trimws(auth_header)
expected_token <- paste("Bearer", config$auth_token)
# Debug log the auth header
logger::log_debug(paste("Auth header:", auth_header))
logger::log_debug(paste("Expected:", paste("Bearer", config$auth_token)))
# if (is.null(auth_header) || auth_header != paste("Bearer", config$auth_token)) {
#   logger::log_warn("Authentication failed")
#   res$status <- 401
#   res$send(list(error = "Unauthorized"))
#   return(FALSE)
# }
#
if (auth_header != expected_token) {
logger::log_warn("Authentication failed. Got: ", auth_header, ", expected: ", expected_token)
res$status <- 401
res$json(list(error = "Unauthorized"))
return(FALSE)
}
return(TRUE)  }, error = function(e){
logger::log_error(paste("Auth limit middleware erro: ", e$message))
res$status = 500
res$json(list(error = "Server error in authentication"))
return(FALSE)
}
)
}
#' Request validation middleware
#'
#' @param schema List defining expected request structure
#' @return Function that validates request against schema
validate_request <- function(schema) {
function(req, res) {
if (!is.null(schema$params)) {
for (param in names(schema$params)) {
if (is.null(req$params[[param]])) {
res$status <- 400
res$send(list(error = sprintf("Missing required parameter: %s", param)))
return(FALSE)
}
}
}
#
if (!is.null(schema$body)) {
body <- tryCatch({
if (is.character(req$body) && nchar(req$body) > 0) {
fromJSON(req$body)
} else {
NULL
}
}, error = function(e) NULL)
if (is.null(body)) {
res$status <- 400
res$json(list(error = "Invalid request body"))
return(FALSE)
}
for (field in schema$body) {
if (is.null(body[[field]])) {
res$status <- 400
res$json(list(error = sprintf("Missing required field: %s", field)))
return(FALSE)
}
}
}
#
return(TRUE)
}
}
#===============================================================================
# Error Handling
#===============================================================================
#' Global error handler
#'
#' @param err Error object
#' @return List containing error details
handle_error <- function(err) {
logger::log_error(sprintf("Error: %s", err$message))
list(
error = TRUE,
message = err$message,
status = 500,
timestamp = format(Sys.time(), "%Y-%m-%d %H:%M:%S")
)
}
#===============================================================================
# Cache Implementation
#===============================================================================
#' Cache wrapper for database queries
#'
#' @param func Function to cache
#' @return Memoized function with timeout
cache_query <- function(func) {
memoise::memoise(
func,
~memoise::timeout(config$cache_ttl)
)
}
# Part 2: API Implementation
create_app <- function() {
app <- Ambiorix$new()
# Debug middleware to log requests
app$use(function(req, res) {
logger::log_debug(paste("Received request:", req$method, req$path))
return(TRUE)
})
# Add middleware - IMPORTANT! These need to be BEFORE route handlers
# app$use(rate_limit_middleware)
# app$use(auth_middleware)
# Basic health check that doesn't require auth
app$get("/health", function(req, res) {
res$json(list(status = "ok", message = "API is running"))
}#, use_middlewares = FALSE
)  # Skip middlewares for health check
# Add middleware with path exclusions
app$use(function(req, res) {
#
# Apply rate limiting
if (!rate_limit_middleware(req, res)) {
return(FALSE)
}
#
if (req$method == "GET" && req$path == "/health"){
return(TRUE)
}
# Apply authentication
if (!auth_middleware(req, res)) {
return(FALSE)
}
return(TRUE)
})
# 1. POST /flight - Create new flight
app$post(
"/flight",
validate_request(list(body = c("year", "month", "day", "dep_time", "carrier", "flight", "origin", "dest"))),
function(req, res) {
tryCatch({
logger::log_info("POST /flight route handler called") # Add this
logger::log_info(paste("Request body:", req$body))
# Debug log the request body
logger::log_debug(paste("Request body:", req$body))
# Safely parse JSON with error handling
if (is.null(req$body) || req$body == "") {
res$status <- 400
res$json(list(error = "Empty request body"))
return(TRUE)
}
flight_data <- tryCatch({
fromJSON(req$body)
}, error = function(e) {
logger::log_error(paste("JSON parse error:", e$message))
res$status <- 400
res$json(list(error = "Invalid JSON in request body"))
return(NULL)
})
if (is.null(flight_data)) return()
logger::log_debug(paste("Parsed flight_data:", str(flight_data)))
con <- get_db_connection()
on.exit(dbDisconnect(con), add = TRUE)
# Get the last flight_id and increment it
last_flight_id_result <- dbGetQuery(con, "SELECT MAX(ID) FROM flights")
last_flight_id <- last_flight_id_result[[1, 1]] # Extract the value
if (is.null(last_flight_id)) {
flight_data$flight_id <- 1 # If no previous records, start with 1
} else {
flight_data$flight_id <- last_flight_id + 1
}
# flight_data <- fromJSON(req$body)
# flight_data$flight_id <- uuid::UUIDgenerate()
# Convert to data frame first
# flight_df <- as.data.frame(flight_data)
flight_df <- data.frame(
year = as.integer(flight_data$year),
month = as.integer(flight_data$month),
day = as.integer(flight_data$day),
dep_time = as.integer(flight_data$dep_time),
carrier = as.character(flight_data$carrier),
flight = as.integer(flight_data$flight),
origin = as.character(flight_data$origin),
dest = as.character(flight_data$dest),
flight_id = as.integer(flight_data$flight_id)
)
dbWriteTable(con, "flights", flight_df, append = TRUE)
logger::log_info(sprintf("Created flight: %s", flight_data$flight_id))
res$json(list(
success = TRUE,
flight_id = flight_data$flight_id
))
}, error = function(err) {
logger::log_error(paste("Error creating flight:", err$message))
res$status <- 500
res$json(handle_error(err))
})
})
# 2. GET /flight/:id - Get flight details
app$get("/flight/:id", function(req, res) {
print(paste("GET /flight/:id called with id:", req$params$id))
print(paste("GET /flight/:id called with id:", unlist(req$params$id)))
logger::log_debug(paste("GET /flight/:id called with id:", req$params$id))
tryCatch({
logger::log_debug(paste("GET /flight/:id called with id:", req$params$id))
logger::log_debug(paste("Request parameters:", paste(names(req$params), req$params, collapse = ", ")))
con <- get_db_connection()
logger::log_debug(paste("Database connection established:", !is.null(con)))
on.exit(dbDisconnect(con), add = TRUE)
query <- "SELECT * FROM flights WHERE ID = ?"
logger::log_debug(paste("Executing SQL query:", query, "with params:", req$params$id))
flight <- dbGetQuery(
con,
"SELECT * FROM flights WHERE ID = ?",
params = unlist(req$params$id) ###
)
logger::log_debug(paste("Query result:", nrow(flight), "rows"))
if (nrow(flight) == 0) {
res$status <- 404
res$json(list(error = "Flight not found"))
return()
}
logger::log_info("GET /flight/:id completed successfully")
res$json(flight)
}, error = function(err) {
logger::log_error(paste("Error in GET /flight/:id:", err$message))
res$status <- 500
res$json(handle_error(err))
})
})
# 3. GET /check-delay/:id - Check if flight was delayed
app$get("/check-delay/:id", function(req, res) {
tryCatch({
con <- get_db_connection()
on.exit(dbDisconnect(con), add = TRUE)
delay_status <- dbGetQuery(
con,
"SELECT is_delayed FROM flights WHERE ID = ?",
params = unlist(req$params$id) ###
)
if (nrow(delay_status) == 0) {
res$status <- 404
res$json(list(error = "Flight not found"))
return()
}
res$json(list(
flight_id = req$params$id,
is_delayed = delay_status$is_delayed
))
}, error = function(err) {
res$status <- 500
res$json(handle_error(err))
})
})
#
# 4. GET /avg-dep-delay - Get average delay by airline
app$get("/avg-dep-delay/:id", function(req, res) {
tryCatch({
con <- get_db_connection()
on.exit(dbDisconnect(con), add = TRUE)
airline <- req$params$id
if (!is.null(airline)) {
query <- "SELECT carrier, AVG(dep_delay) AS avg_delay FROM flights WHERE carrier = ?"
params <- list(airline)
delays <- dbGetQuery(con, query, params = params)
if (nrow(delays) == 0) {
res$status <- 404
res$json(list(error = "Carrier not found"))
return()
}
} else {
#This else statement will not be used, because :id is required.
query <- "SELECT carrier, AVG(dep_delay) AS avg_delay FROM flights GROUP BY carrier"
delays <- dbGetQuery(con, query)
}
res$json(delays)
}, error = function(err) {
res$status <- 500
res$json(handle_error(err))
})
})
#
# 5. GET /top-destinations/:n - Get top n destinations
app$get("/top-destinations/:n", function(req, res) {
tryCatch({
con <- get_db_connection()
on.exit(dbDisconnect(con), add = TRUE)
n <- as.integer(req$params$n)
if (is.na(n) || n <= 0) {
res$status <- 400
res$json(list(error = "Invalid number of destinations requested"))
return()
}
top_dest <- dbGetQuery(
con,
"SELECT dest, COUNT(*) as flight_count
FROM flights
GROUP BY dest
ORDER BY flight_count DESC
LIMIT ?",
params = list(n)
)
res$json(top_dest)
}, error = function(err) {
res$status <- 500
res$json(handle_error(err))
})
})
#
# 6. PUT /flights/:id - Update flight details
app$put("/flights/:id", function(req, res) {
tryCatch({
logger::log_info("FLIGHT PUT")
# body existand is parse able
if (is.null(req$body)){
res$status = 400
res$json(list(error = "Empty request body"))
return(TRUE)
}
# ensure body is character string
body_text = if (is.character(req$body)){
req$body
} else {
tryCatch({
as.character(req$body)
}, error = function(e){
NULL
})
}
if (is.null(body_text) || nchar(body_text) == 0){
res$status = 400
res$json(list(error = "Invalid request body"))
return(TRUE)
}
flight_data <- jsonlite::fromJSON(req$body)
#
con <- get_db_connection()
on.exit(dbDisconnect(con), add = TRUE)
#
# Check if flight exists
exists <- dbGetQuery(
con,
"SELECT 1 FROM flights WHERE ID = ?",
params = list(req$params$id) ###
)
if (nrow(exists) == 0) {
res$status <- 404
res$json(list(error = "Flight not found"))
return(TRUE)
}
#
# # Build update query dynamically based on provided fields
update_fields <- names(flight_data)
#
# check if fields are procided
if (length(update_fields) == 0){
res$status <- 400
res$json(list(error = "No fields provided for update"))
return(TRUE)
}
set_clause <- paste(update_fields, "= ?", collapse = ", ")
#
query <- sprintf(
"UPDATE flights SET %s WHERE ID = ?",
set_clause
)
# print(query)
#
params <- c(as.list(flight_data), list(req$params$id))
dbExecute(con, query, params = params)
res$json(list(
success = TRUE,
message = "Flight updated successfully"
))
}, error = function(err) {
logger::log_error(paste("Error: ", err$message))
res$status <- 500
res$json(handle_error(err))
})
})
#
# 7. DELETE /:id - Delete flight
app$delete("/:id", function(req, res) {
tryCatch({
con <- get_db_connection()
on.exit(dbDisconnect(con), add = TRUE)
result <- dbExecute(
con,
"DELETE FROM flights WHERE ID = ?",
params = list(req$params$id)
)
if (result == 0) {
res$status <- 404
res$json(list(error = "Flight not found"))
return()
}
res$json(list(
success = TRUE,
message = "Flight deleted successfully"
))
}, error = function(err) {
res$status <- 500
res$json(handle_error(err))
})
})
return(app)
}
#===============================================================================
# Server Initialization
#===============================================================================
# Initialize application
init_app <- function() {
logger::log_info("Application initialization started.")
# Set start time
Sys.setenv(R_START_TIME = as.character(Sys.time()))
# Setup logging
log_setup()
logger::log_info("Logging setup completed.")
# Process data and setup database
logger::log_info("Initializing application")
# Process data and setup database
processed_data <- process_flights_data()
logger::log_info("Data processing completed.")
setup_database(processed_data)
logger::log_info("Database setup completed.")
# Create app with routes
app <- create_app()
# Start server
logger::log_info(sprintf("Starting server on port %d", config$port))
logger::log_debug(paste("Port:", config$port))
logger::log_debug(paste("Port Type:", typeof(config$port)))
logger::log_debug(paste("Host:", "127.0.0.1"))
logger::log_debug(paste("Host Type:", typeof("127.0.0.1")))
app$start(port = config$port, host = "127.0.0.1")
logger::log_info("Server started.")
}
# For non-test mode, start the application
if (!interactive()) {
init_app()
}
init_app()
