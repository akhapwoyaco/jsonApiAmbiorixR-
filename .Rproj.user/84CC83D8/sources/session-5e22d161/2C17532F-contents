# Update UI elements based on data
    observe({
      req(data$getRawData())
      
      # Update metric choices for visualization
      metric_cols <- names(data$getRawData())[grep("^metric_", names(data$getRawData()))]
      updateSelectInput(session, "selected_metric",
                       choices = metric_cols,
                       selected = metric_cols[1])
      
      # Update year range based on available data
      year_range <- range(data$getRawData()$year, na.rm = TRUE)
      updateSliderInput(session, "year_range",
                       min = year_range[1],
                       max = year_range[2],
                       value = year_range)
    })
    
    # Data Preview
    output$data_preview <- renderDT({
      req(data$getRawData())
      datatable(
        data$getRawData(),
        options = list(
          pageLength = 10,
          scrollX = TRUE,
          dom = 'Bfrtip',
          buttons = c('copy', 'csv', 'excel')
        ),
        filter = 'top',
        selection = 'none'
      )
    })
    
    # Analysis Plot Output
    output$analysis_plot <- renderPlotly({
      req(data$getData(), input$analysis_type)
      
      switch(input$analysis_type,
             "Clustering" = {
               # Cluster visualization
               cluster_data <- data$getData() %>%
                 select(starts_with("metric_")) %>%
                 scale()
               
               fviz_cluster(analysis$getClusters(),
                          data = cluster_data,
                          geom = "point",
                          ellipse.type = "convex") %>%
                 ggplotly()
             },
             "Time Series" = {
               # Time series plot
               ggplotly(analysis$getTimeSeries())
             },
             "Statistical Summary" = {
               # Summary statistics plot
               ggplotly(analysis$getSummaries())
             }
      )
    })
    
    # Error Handling
    observeEvent(data$getStatus(), {
      if (!is.null(data$getStatus()$data_load) && 
          grepl("^Error:", data$getStatus()$data_load)) {
        showNotification(
          data$getStatus()$data_load,
          type = "error",
          duration = NULL
        )
      }
    })
})

# Data Validation Function
validateMortalityData <- function(data) {
  # Required columns
  required_cols <- c("country", "country_code", "year")
  missing_cols <- setdiff(required_cols, names(data))
  
  if (length(missing_cols) > 0) {
    stop(paste("Missing required columns:", 
               paste(missing_cols, collapse = ", ")))
  }
  
  # Check for metric columns
  metric_cols <- grep("^metric_", names(data), value = TRUE)
  if (length(metric_cols) == 0) {
    stop("No metric columns found (should start with 'metric_')")
  }
  
  # Validate data types
  if (!is.numeric(data$year)) {
    stop("Year column must be numeric")
  }
  
  # Check for invalid values in metric columns
  for (col in metric_cols) {
    if (!is.numeric(data[[col]])) {
      stop(paste("Metric column", col, "must be numeric"))
    }
    if (any(data[[col]] < 0, na.rm = TRUE)) {
      stop(paste("Negative values found in", col))
    }
  }
  
  # Check for duplicate entries
  dupes <- data %>%
    group_by(country_code, year) %>%
    filter(n() > 1) %>%
    ungroup()
  
  if (nrow(dupes) > 0) {
    stop("Duplicate entries found for some country-year combinations")
  }
}

# Run the application
shinyApp(ui = ui, server = server)